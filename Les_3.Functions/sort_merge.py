#Сортировка слиянием с рекурсией

def sort_merge(nums):
    if len(nums) > 1:     #Выполняем рекурсию пока список больше 1 элемента:
        mid = len(nums) // 2      # Делим длину нашего списка на 2 и задаем это значение в mid
        left = nums[:mid]         #Создаем список left с элементами nums от 0 до mid(не включ)
        right = nums[mid:]         #Создаем список right с элементами nums от  mid(включ) до конца
        sort_merge(right)          #запускаем рекурсию для списка right
        sort_merge(left)           #запускаем рекурсию для списка left

        i = j = k = 0              #задаем переменные для перебора (i j) и конечную k

        while i < len(left) and j < len(right):         #до тех пор пока i меньше длины left и j меньше длины right

            if left[i] < right[j]:                      # если i-ый элемент left меньше j-го right
                nums[k] = left[i]                       #записываем на k-ый элемент списка nums left[i] (то есть меньшее)
                i +=1                                   #и увеличиваем i на единицу
            else:
                nums[k] = right[j]                       #иначе записываем на k-ый элемент списка nums right[j] 
                                                         #(то есть все равно меньшее)
                j += 1                                   #и увеличиваем j на единицу
            k += 1                                        #Произведя вычисления выше, увеличиваем k на единицу
                                                         # и запускаем цикл по-новой

        while i < len(left):                              #если пройдя цикл выше, мы не добрались до конечного
                                                          # индекса списка left, запускаем новый цикл:
            nums[k] = left[i]                             #записываем в конец списка nums (k увеличено 
                                                          #последним действием прошлого цикла) i-ый элемент
            i += 1                                        #увеличиваем k и i на единицу и записываем дальше
            k += 1
        while j < len(right):                             #если пройдя цикл выше, мы не добрались до конечного
                                                          # индекса списка right, запускаем новый цикл:
            nums[k] = right[j]                             #записываем в конец списка nums (k увеличено 
                                                          #последним действием прошлого цикла) j-ый элемент
            j += 1                                        #увеличиваем k и j на единицу и записываем дальше
            k += 1


list_1 = [1, 6, 2, 4, 6, 8, 90, 32, 44, 5]
sort_merge(list_1)
print(list_1)